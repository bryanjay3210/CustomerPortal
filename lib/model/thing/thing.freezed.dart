// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'thing.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Thing _$ThingFromJson(Map<String, dynamic> json) {
  return _Thing.fromJson(json);
}

/// @nodoc
mixin _$Thing {
  dynamic get ItemLabel => throw _privateConstructorUsedError;
  dynamic get ThingHumanName => throw _privateConstructorUsedError;
  dynamic get ItemState => throw _privateConstructorUsedError;
  dynamic get ItemCategory => throw _privateConstructorUsedError;
  dynamic get ItemName => throw _privateConstructorUsedError;
  dynamic get ThingUUID => throw _privateConstructorUsedError;
  dynamic get ThingID => throw _privateConstructorUsedError;
  dynamic get ItemID => throw _privateConstructorUsedError;
  dynamic get ChannelUUID => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ThingCopyWith<Thing> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThingCopyWith<$Res> {
  factory $ThingCopyWith(Thing value, $Res Function(Thing) then) =
      _$ThingCopyWithImpl<$Res, Thing>;
  @useResult
  $Res call(
      {dynamic ItemLabel,
      dynamic ThingHumanName,
      dynamic ItemState,
      dynamic ItemCategory,
      dynamic ItemName,
      dynamic ThingUUID,
      dynamic ThingID,
      dynamic ItemID,
      dynamic ChannelUUID});
}

/// @nodoc
class _$ThingCopyWithImpl<$Res, $Val extends Thing>
    implements $ThingCopyWith<$Res> {
  _$ThingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ItemLabel = freezed,
    Object? ThingHumanName = freezed,
    Object? ItemState = freezed,
    Object? ItemCategory = freezed,
    Object? ItemName = freezed,
    Object? ThingUUID = freezed,
    Object? ThingID = freezed,
    Object? ItemID = freezed,
    Object? ChannelUUID = freezed,
  }) {
    return _then(_value.copyWith(
      ItemLabel: freezed == ItemLabel
          ? _value.ItemLabel
          : ItemLabel // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ThingHumanName: freezed == ThingHumanName
          ? _value.ThingHumanName
          : ThingHumanName // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ItemState: freezed == ItemState
          ? _value.ItemState
          : ItemState // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ItemCategory: freezed == ItemCategory
          ? _value.ItemCategory
          : ItemCategory // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ItemName: freezed == ItemName
          ? _value.ItemName
          : ItemName // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ThingUUID: freezed == ThingUUID
          ? _value.ThingUUID
          : ThingUUID // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ThingID: freezed == ThingID
          ? _value.ThingID
          : ThingID // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ItemID: freezed == ItemID
          ? _value.ItemID
          : ItemID // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ChannelUUID: freezed == ChannelUUID
          ? _value.ChannelUUID
          : ChannelUUID // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ThingCopyWith<$Res> implements $ThingCopyWith<$Res> {
  factory _$$_ThingCopyWith(_$_Thing value, $Res Function(_$_Thing) then) =
      __$$_ThingCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic ItemLabel,
      dynamic ThingHumanName,
      dynamic ItemState,
      dynamic ItemCategory,
      dynamic ItemName,
      dynamic ThingUUID,
      dynamic ThingID,
      dynamic ItemID,
      dynamic ChannelUUID});
}

/// @nodoc
class __$$_ThingCopyWithImpl<$Res> extends _$ThingCopyWithImpl<$Res, _$_Thing>
    implements _$$_ThingCopyWith<$Res> {
  __$$_ThingCopyWithImpl(_$_Thing _value, $Res Function(_$_Thing) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ItemLabel = freezed,
    Object? ThingHumanName = freezed,
    Object? ItemState = freezed,
    Object? ItemCategory = freezed,
    Object? ItemName = freezed,
    Object? ThingUUID = freezed,
    Object? ThingID = freezed,
    Object? ItemID = freezed,
    Object? ChannelUUID = freezed,
  }) {
    return _then(_$_Thing(
      ItemLabel: freezed == ItemLabel
          ? _value.ItemLabel
          : ItemLabel // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ThingHumanName: freezed == ThingHumanName
          ? _value.ThingHumanName
          : ThingHumanName // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ItemState: freezed == ItemState
          ? _value.ItemState
          : ItemState // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ItemCategory: freezed == ItemCategory
          ? _value.ItemCategory
          : ItemCategory // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ItemName: freezed == ItemName
          ? _value.ItemName
          : ItemName // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ThingUUID: freezed == ThingUUID
          ? _value.ThingUUID
          : ThingUUID // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ThingID: freezed == ThingID
          ? _value.ThingID
          : ThingID // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ItemID: freezed == ItemID
          ? _value.ItemID
          : ItemID // ignore: cast_nullable_to_non_nullable
              as dynamic,
      ChannelUUID: freezed == ChannelUUID
          ? _value.ChannelUUID
          : ChannelUUID // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Thing with DiagnosticableTreeMixin implements _Thing {
  _$_Thing(
      {this.ItemLabel = '',
      this.ThingHumanName = '',
      this.ItemState = '',
      this.ItemCategory = '',
      this.ItemName = '',
      this.ThingUUID = '',
      this.ThingID = '',
      this.ItemID = '',
      this.ChannelUUID = ''});

  factory _$_Thing.fromJson(Map<String, dynamic> json) =>
      _$$_ThingFromJson(json);

  @override
  @JsonKey()
  final dynamic ItemLabel;
  @override
  @JsonKey()
  final dynamic ThingHumanName;
  @override
  @JsonKey()
  final dynamic ItemState;
  @override
  @JsonKey()
  final dynamic ItemCategory;
  @override
  @JsonKey()
  final dynamic ItemName;
  @override
  @JsonKey()
  final dynamic ThingUUID;
  @override
  @JsonKey()
  final dynamic ThingID;
  @override
  @JsonKey()
  final dynamic ItemID;
  @override
  @JsonKey()
  final dynamic ChannelUUID;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Thing(ItemLabel: $ItemLabel, ThingHumanName: $ThingHumanName, ItemState: $ItemState, ItemCategory: $ItemCategory, ItemName: $ItemName, ThingUUID: $ThingUUID, ThingID: $ThingID, ItemID: $ItemID, ChannelUUID: $ChannelUUID)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Thing'))
      ..add(DiagnosticsProperty('ItemLabel', ItemLabel))
      ..add(DiagnosticsProperty('ThingHumanName', ThingHumanName))
      ..add(DiagnosticsProperty('ItemState', ItemState))
      ..add(DiagnosticsProperty('ItemCategory', ItemCategory))
      ..add(DiagnosticsProperty('ItemName', ItemName))
      ..add(DiagnosticsProperty('ThingUUID', ThingUUID))
      ..add(DiagnosticsProperty('ThingID', ThingID))
      ..add(DiagnosticsProperty('ItemID', ItemID))
      ..add(DiagnosticsProperty('ChannelUUID', ChannelUUID));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Thing &&
            const DeepCollectionEquality().equals(other.ItemLabel, ItemLabel) &&
            const DeepCollectionEquality()
                .equals(other.ThingHumanName, ThingHumanName) &&
            const DeepCollectionEquality().equals(other.ItemState, ItemState) &&
            const DeepCollectionEquality()
                .equals(other.ItemCategory, ItemCategory) &&
            const DeepCollectionEquality().equals(other.ItemName, ItemName) &&
            const DeepCollectionEquality().equals(other.ThingUUID, ThingUUID) &&
            const DeepCollectionEquality().equals(other.ThingID, ThingID) &&
            const DeepCollectionEquality().equals(other.ItemID, ItemID) &&
            const DeepCollectionEquality()
                .equals(other.ChannelUUID, ChannelUUID));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(ItemLabel),
      const DeepCollectionEquality().hash(ThingHumanName),
      const DeepCollectionEquality().hash(ItemState),
      const DeepCollectionEquality().hash(ItemCategory),
      const DeepCollectionEquality().hash(ItemName),
      const DeepCollectionEquality().hash(ThingUUID),
      const DeepCollectionEquality().hash(ThingID),
      const DeepCollectionEquality().hash(ItemID),
      const DeepCollectionEquality().hash(ChannelUUID));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ThingCopyWith<_$_Thing> get copyWith =>
      __$$_ThingCopyWithImpl<_$_Thing>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ThingToJson(
      this,
    );
  }
}

abstract class _Thing implements Thing {
  factory _Thing(
      {final dynamic ItemLabel,
      final dynamic ThingHumanName,
      final dynamic ItemState,
      final dynamic ItemCategory,
      final dynamic ItemName,
      final dynamic ThingUUID,
      final dynamic ThingID,
      final dynamic ItemID,
      final dynamic ChannelUUID}) = _$_Thing;

  factory _Thing.fromJson(Map<String, dynamic> json) = _$_Thing.fromJson;

  @override
  dynamic get ItemLabel;
  @override
  dynamic get ThingHumanName;
  @override
  dynamic get ItemState;
  @override
  dynamic get ItemCategory;
  @override
  dynamic get ItemName;
  @override
  dynamic get ThingUUID;
  @override
  dynamic get ThingID;
  @override
  dynamic get ItemID;
  @override
  dynamic get ChannelUUID;
  @override
  @JsonKey(ignore: true)
  _$$_ThingCopyWith<_$_Thing> get copyWith =>
      throw _privateConstructorUsedError;
}
